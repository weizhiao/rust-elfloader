mod common;

use elf_loader::{
    Loader, Relocatable,
    arch::{REL_GOT, REL_JUMP_SLOT, REL_RELATIVE, REL_SYMBOLIC},
    object::ElfBinary,
};
use gen_relocs::{DylibWriter, ElfWriterConfig, RelocEntry, SymbolDesc};
use rstest::rstest;
use std::collections::HashMap;

use crate::common::{
    EXTERNAL_FUNC_NAME, EXTERNAL_TLS_NAME, EXTERNAL_VAR_NAME, LOCAL_VAR_NAME, get_arch,
};

fn get_relocs_dynamic() -> Vec<RelocEntry> {
    vec![
        RelocEntry::new(EXTERNAL_FUNC_NAME, REL_JUMP_SLOT), // R_X86_64_JUMP_SLOT
        RelocEntry::new(EXTERNAL_VAR_NAME, REL_GOT),        // R_X86_64_GLOB_DAT
        RelocEntry::new("", REL_RELATIVE),                  // R_X86_64_RELATIVE
        RelocEntry::new(LOCAL_VAR_NAME, REL_SYMBOLIC),      // R_X86_64_64
    ]
}

/// Helper function to describe relocation types for x86_64
fn describe_reloc_type(r_type: u32) -> &'static str {
    match r_type {
        1 => "R_X86_64_64 (Direct 64-bit address)",
        6 => "R_X86_64_GLOB_DAT (Global data symbol)",
        7 => "R_X86_64_JUMP_SLOT (PLT entry)",
        8 => "R_X86_64_RELATIVE (Relative address)",
        _ => "Unknown",
    }
}

#[rstest]
fn relocate_dynamic_fixture() {
    run_dynamic_linking_test(false);
}

#[rstest]
fn relocate_dynamic_fixture_with_lazy() {
    run_dynamic_linking_test(true);
}

fn run_dynamic_linking_test(is_lazy: bool) {
    // Generate ELF in memory using ElfWriter with optimized configuration
    let config = ElfWriterConfig::default();

    let writer = DylibWriter::with_config(get_arch(), config);
    let relocs = get_relocs_dynamic();
    let symbols = vec![
        SymbolDesc::global_object(LOCAL_VAR_NAME, &[0u8; 8]),
        SymbolDesc::undefined_func(EXTERNAL_FUNC_NAME),
        SymbolDesc::undefined_object(EXTERNAL_VAR_NAME),
        SymbolDesc::undefined_object(EXTERNAL_TLS_NAME),
    ];

    let elf_output = writer
        .write(&relocs, &symbols)
        .expect("Failed to generate ELF");

    let test_name = if is_lazy {
        "Lazy Binding Test"
    } else {
        "Standard Binding Test"
    };
    println!("\n=== ELF Generated by gen_relocs ({}) ===", test_name);
    println!("ELF Binary Properties:");
    println!("  Total size: 0x{:x} bytes", elf_output.data.len());
    println!("  Base address (generation): 0x{:x}", elf_output.base_addr);
    println!("  Data segment vaddr: 0x{:x}", elf_output.data_vaddr);
    println!("  Text segment vaddr: 0x{:x}", elf_output.text_vaddr);
    println!("  Total relocations: {}", elf_output.relocations.len());

    // Save the ELF to a file for inspection
    let elf_path = "/tmp/test_dynamic.so";
    std::fs::write(elf_path, &elf_output.data).expect("Failed to write ELF to file");
    println!("  Saved ELF to {} for inspection", elf_path);

    // Define external symbols that the dynamic library requires
    extern "C" fn external_func() -> i32 {
        println!("  [Called] external_func()");
        42
    }

    static mut EXTERNAL_VAR: i32 = 100;
    thread_local! {
        static EXTERNAL_TLS: std::cell::Cell<i32> = std::cell::Cell::new(200);
    }

    let mut symbol_map = HashMap::new();
    symbol_map.insert(EXTERNAL_FUNC_NAME, external_func as *const ());
    symbol_map.insert(EXTERNAL_VAR_NAME, &raw const EXTERNAL_VAR as *const ());

    EXTERNAL_TLS.with(|tls| {
        symbol_map.insert(EXTERNAL_TLS_NAME, tls.as_ptr() as *const ());
    });

    let symbol_lookup_map = symbol_map.clone();
    let symbol_lookup = move |name: &str| -> Option<*const ()> {
        let result = symbol_lookup_map.get(name).copied();
        if result.is_some() {
            println!("  [Symbol Lookup] '{}' => {:?}", name, result);
        } else {
            println!("  [Symbol Lookup] '{}' => NOT FOUND", name);
        }
        result
    };

    println!("\n=== Loading ELF with elf_loader ===");

    // Create ElfBinary from generated bytes
    let elf_binary = ElfBinary::new("test_dynamic.so", &elf_output.data);

    // Load the dynamic library
    let mut loader = Loader::new();
    let dylib = loader
        .load_dylib(elf_binary)
        .expect("Failed to load dynamic library");

    println!("✓ Dynamic library loaded successfully");

    // Relocate the library with symbol resolution
    println!("\n=== Relocating Dynamic Library ({}) ===", test_name);
    let relocator = dylib.relocator().symbols(&symbol_lookup).lazy(is_lazy);

    let relocated = if is_lazy {
        relocator.use_scope_as_lazy().relocate()
    } else {
        relocator.relocate()
    }
    .expect("Failed to relocate dynamic library");

    println!("✓ Dynamic library relocated successfully");

    // Verify relocation entries comprehensively
    println!("\n=== Verifying All Relocations ({}) ===", test_name);
    println!("Total relocations: {}", elf_output.relocations.len());

    // Create a summary of relocations by type
    let mut reloc_by_type: HashMap<u32, usize> = HashMap::new();
    for reloc_info in &elf_output.relocations {
        *reloc_by_type.entry(reloc_info.r_type).or_insert(0) += 1;
    }

    println!("\nRelocation Summary by Type:");
    for (r_type, count) in &reloc_by_type {
        println!("  {}: {} entries", describe_reloc_type(*r_type), count);
    }

    // Get the actual base address where the library was loaded
    let actual_base = relocated.base();
    println!(
        "\nActual load base: 0x{:x}, Generation base: 0x{:x}",
        actual_base, elf_output.base_addr
    );
    println!("Data segment vaddr (gen): 0x{:x}", elf_output.data_vaddr);
    println!(
        "Expected data in memory: 0x{:x}",
        actual_base + (elf_output.data_vaddr - elf_output.base_addr) as usize
    );

    // Detailed verification of each relocation entry with memory value checks
    println!("\nDetailed Relocation Entries with Memory Verification:");

    for (idx, reloc_info) in elf_output.relocations.iter().enumerate() {
        println!("\n  [Relocation {}]", idx);
        println!("    vaddr (gen): 0x{:x}", reloc_info.vaddr);
        println!(
            "    type:  {} ({})",
            reloc_info.r_type,
            describe_reloc_type(reloc_info.r_type)
        );
        println!("    sym_idx: {}", reloc_info.sym_idx);
        println!("    addend: 0x{:x}", reloc_info.addend);

        // Calculate the real address in loaded memory
        let real_addr = actual_base + reloc_info.vaddr as usize;
        println!("    real_addr: 0x{:x}", real_addr);

        // Read and verify the value at the relocation address
        unsafe {
            let ptr = real_addr as *const u64;
            let actual_value = *ptr;
            println!("    actual_value: 0x{:x}", actual_value);

            // Calculate expected value based on relocation type
            match reloc_info.r_type {
                REL_SYMBOLIC | REL_GOT | REL_JUMP_SLOT => {
                    let (_, sym_info) = relocated.symtab().symbol_idx(reloc_info.sym_idx as usize);
                    let sym_name = sym_info.name();

                    let s = if let Some(addr) = symbol_map.get(sym_name) {
                        *addr as u64
                    } else {
                        // If not in external symbol map, it might be internal
                        relocated
                            .get::<*const ()>(sym_name)
                            .map(|s| s.into_raw() as u64)
                            .unwrap_or(0)
                    };

                    if reloc_info.r_type == REL_JUMP_SLOT && is_lazy {
                        // With lazy binding, JUMP_SLOT points to PLT stub
                        if actual_value != 0 {
                            println!("    ✓ PLT entry initialized (may resolve lazily)");
                        }
                    } else {
                        let expected_value = if reloc_info.r_type == REL_SYMBOLIC {
                            s.wrapping_add(reloc_info.addend as u64)
                        } else {
                            s
                        };
                        println!("    expected_value: 0x{:x}", expected_value);
                        assert!(
                            actual_value == expected_value,
                            "    ✗ Value mismatch! Expected 0x{:x}, got 0x{:x}",
                            expected_value,
                            actual_value
                        );
                    }
                }
                REL_RELATIVE => {
                    let expected_value = (actual_base as i64 + reloc_info.addend) as u64;
                    println!("    expected_value: 0x{:x}", expected_value);
                    assert!(
                        actual_value == expected_value,
                        "    ✗ Relative mismatch! Expected 0x{:x}, got 0x{:x}",
                        expected_value,
                        actual_value
                    );
                }
                _ => {
                    panic!("    ✗ Unknown type, value present: 0x{:x}", actual_value);
                }
            }
        }
    }

    println!("\n=== Verification Summary ===");
    println!("✓ ELF generation with gen_relocs: OK");
    println!("✓ ELF loading with elf_loader: OK");
    println!("✓ Dynamic library relocation: OK");
    println!("✓ Symbol resolution: OK");
    println!("✓ Test completed successfully");
}
