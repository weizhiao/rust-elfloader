mod common;

use elf_loader::{Loader, Relocatable, object::ElfBinary};
use rstest::rstest;
use std::collections::HashMap;

#[rstest]
fn relocate_dynamic_fixture() {
    use gen_relocs::Arch;
    use gen_relocs::writer::{ElfWriter, ElfWriterConfig, SymbolDesc};

    // Generate ELF in memory using ElfWriter with optimized configuration
    let config = ElfWriterConfig::default().with_initial_data_size(0x2000);

    let writer = ElfWriter::with_config(Arch::X86_64, config);
    let relocs = gen_relocs::get_relocs_dynamic(Arch::X86_64);
    let symbols = vec![
        SymbolDesc::local_var(gen_relocs::LOCAL_VAR_NAME, gen_relocs::LOCAL_VAR_OFF as u16),
        SymbolDesc::global_func(gen_relocs::EXTERNAL_FUNC_NAME),
        SymbolDesc::global_object(gen_relocs::EXTERNAL_VAR_NAME),
        SymbolDesc::global_object(gen_relocs::EXTERNAL_TLS_NAME),
    ];

    let elf_output = writer
        .write_elf(&relocs, &symbols)
        .expect("Failed to generate ELF");

    println!("\n=== ELF Generated by gen_relocs ===");
    println!("ELF Binary Properties:");
    println!("  Total size: 0x{:x} bytes", elf_output.data.len());
    println!("  Base address (generation): 0x{:x}", elf_output.base_addr);
    println!("  Data segment vaddr: 0x{:x}", elf_output.data_vaddr);
    println!("  Text segment vaddr: 0x{:x}", elf_output.text_vaddr);
    println!("  Total relocations: {}", elf_output.relocations.len());

    // Save the ELF to a file for inspection
    std::fs::write("/tmp/test_dynamic.so", &elf_output.data).expect("Failed to write ELF to file");
    println!("  Saved ELF to /tmp/test_dynamic.so for inspection");

    // Define external symbols that the dynamic library requires
    extern "C" fn external_func() -> i32 {
        println!("  [Called] external_func()");
        42
    }

    static mut EXTERNAL_VAR: i32 = 100;
    thread_local! {
        static EXTERNAL_TLS: std::cell::Cell<i32> = std::cell::Cell::new(200);
    }

    let mut symbol_map = HashMap::new();
    symbol_map.insert(gen_relocs::EXTERNAL_FUNC_NAME, external_func as *const ());
    symbol_map.insert(gen_relocs::EXTERNAL_VAR_NAME, unsafe {
        &raw const EXTERNAL_VAR as *const ()
    });

    // TLS symbols are more complex, for now we just provide a placeholder
    // In a real scenario, the loader would handle TLS properly
    EXTERNAL_TLS.with(|tls| {
        symbol_map.insert(gen_relocs::EXTERNAL_TLS_NAME, tls.as_ptr() as *const ());
    });

    let symbol_lookup = move |name: &str| -> Option<*const ()> {
        let result = symbol_map.get(name).copied();
        if result.is_some() {
            println!("  [Symbol Lookup] '{}' => {:?}", name, result);
        } else {
            println!("  [Symbol Lookup] '{}' => NOT FOUND", name);
        }
        result
    };

    println!("\n=== Loading ELF with elf_loader ===");

    // Create ElfBinary from generated bytes
    let elf_binary = ElfBinary::new("test_dynamic.so", &elf_output.data);

    // Load the dynamic library
    let mut loader = Loader::new();
    let dylib = loader
        .load_dylib(elf_binary)
        .expect("Failed to load dynamic library");

    println!("✓ Dynamic library loaded successfully");

    // Relocate the library with symbol resolution
    println!("\n=== Relocating Dynamic Library ===");
    let relocated = dylib
        .relocator()
        .symbols(&symbol_lookup)
        .lazy(false) // Disable lazy binding for this test
        .relocate()
        .expect("Failed to relocate dynamic library");

    println!("✓ Dynamic library relocated successfully");

    // Verify that we can access symbols from the loaded library
    println!("\n=== Testing Symbol Access ===");

    // Try to get the local variable
    unsafe {
        if let Some(local_var_ptr) = relocated.get::<*const u64>(gen_relocs::LOCAL_VAR_NAME) {
            let local_var_value = **local_var_ptr;
            println!("  ✓ local_var value: 0x{:x}", local_var_value);
        } else {
            println!("  ⚠ Could not retrieve local_var symbol");
        }
    }

    println!("\n=== Verification Summary ===");
    println!("✓ ELF generation with gen_relocs: OK");
    println!("✓ ELF loading with elf_loader: OK");
    println!("✓ Dynamic library relocation: OK");
    println!("✓ Symbol resolution: OK");
    println!("✓ Test completed successfully");
}

#[rstest]
fn relocate_dynamic_fixture_with_lazy() {
    use gen_relocs::Arch;
    use gen_relocs::writer::{ElfWriter, ElfWriterConfig, SymbolDesc};

    // Generate ELF in memory using ElfWriter with optimized configuration
    let config = ElfWriterConfig::default().with_initial_data_size(0x2000);

    let writer = ElfWriter::with_config(Arch::X86_64, config);
    let relocs = gen_relocs::get_relocs_dynamic(Arch::X86_64);
    let symbols = vec![
        SymbolDesc::local_var(gen_relocs::LOCAL_VAR_NAME, gen_relocs::LOCAL_VAR_OFF as u16),
        SymbolDesc::global_func(gen_relocs::EXTERNAL_FUNC_NAME),
        SymbolDesc::global_object(gen_relocs::EXTERNAL_VAR_NAME),
        SymbolDesc::global_object(gen_relocs::EXTERNAL_TLS_NAME),
    ];

    let elf_output = writer
        .write_elf(&relocs, &symbols)
        .expect("Failed to generate ELF");

    println!("\n=== ELF Generated by gen_relocs (Lazy Binding Test) ===");
    println!("ELF Binary Properties:");
    println!("  Total size: 0x{:x} bytes", elf_output.data.len());
    println!("  Base address (generation): 0x{:x}", elf_output.base_addr);
    println!("  Data segment vaddr: 0x{:x}", elf_output.data_vaddr);
    println!("  Text segment vaddr: 0x{:x}", elf_output.text_vaddr);
    println!("  Total relocations: {}", elf_output.relocations.len());

    // Define external symbols that the dynamic library requires
    extern "C" fn external_func() -> i32 {
        println!("  [Called] external_func()");
        42
    }

    static mut EXTERNAL_VAR: i32 = 100;
    thread_local! {
        static EXTERNAL_TLS: std::cell::Cell<i32> = std::cell::Cell::new(200);
    }

    let mut symbol_map = HashMap::new();
    symbol_map.insert(gen_relocs::EXTERNAL_FUNC_NAME, external_func as *const ());
    symbol_map.insert(
        gen_relocs::EXTERNAL_VAR_NAME,
        &raw const EXTERNAL_VAR as *const (),
    );

    EXTERNAL_TLS.with(|tls| {
        symbol_map.insert(gen_relocs::EXTERNAL_TLS_NAME, tls.as_ptr() as *const ());
    });

    let symbol_lookup = move |name: &str| -> Option<*const ()> {
        let result = symbol_map.get(name).copied();
        if result.is_some() {
            println!("  [Symbol Lookup] '{}' => {:?}", name, result);
        } else {
            println!("  [Symbol Lookup] '{}' => NOT FOUND", name);
        }
        result
    };

    println!("\n=== Loading ELF with elf_loader ===");

    // Create ElfBinary from generated bytes
    let elf_binary = ElfBinary::new("test_dynamic_lazy.so", &elf_output.data);

    // Load the dynamic library
    let mut loader = Loader::new();
    let dylib = loader
        .load_dylib(elf_binary)
        .expect("Failed to load dynamic library");

    println!("✓ Dynamic library loaded successfully");

    // Relocate the library with symbol resolution - ENABLE lazy binding
    println!("\n=== Relocating Dynamic Library with Lazy Binding ===");
    let relocated = dylib
        .relocator()
        .symbols(&symbol_lookup)
        .lazy(true)
        .use_scope_as_lazy()
        .relocate()
        .expect("Failed to relocate dynamic library with lazy binding");

    println!("✓ Dynamic library relocated successfully with lazy binding");

    println!("\n=== Verification Summary ===");
    println!("✓ ELF generation with gen_relocs: OK");
    println!("✓ ELF loading with elf_loader: OK");
    println!("✓ Dynamic library relocation with lazy binding: OK");
    println!("✓ Test completed successfully");
}
