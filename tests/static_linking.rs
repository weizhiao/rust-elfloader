mod common;

use elf_loader::{Loader, Relocatable, object::ElfBinary};
use gen_relocs::{Arch, RelocEntry, SymbolDesc, gen_static_elf};
use rstest::rstest;
use std::collections::HashMap;

use crate::common::{
    EXTERNAL_FUNC_NAME, EXTERNAL_TLS_NAME, EXTERNAL_VAR_NAME, LOCAL_VAR_NAME, get_arch,
};

#[rstest]
fn test_static_relocation() {
    let arch = get_arch();

    // Define symbols
    let symbols = vec![
        SymbolDesc::global_object(LOCAL_VAR_NAME, &[0u8; 0x100]), // 0x100 bytes of data
        SymbolDesc::undefined_func(EXTERNAL_FUNC_NAME),
        SymbolDesc::undefined_object(EXTERNAL_VAR_NAME),
        SymbolDesc::undefined_object(EXTERNAL_TLS_NAME),
    ];

    // Define relocations for x86_64
    let relocs = match arch {
        Arch::X86_64 => vec![
            RelocEntry::new(EXTERNAL_FUNC_NAME, 1), // R_X86_64_64
            RelocEntry::new(EXTERNAL_VAR_NAME, 9),  // R_X86_64_GOTPCREL
            RelocEntry::new(EXTERNAL_FUNC_NAME, 9), // R_X86_64_GOTPCREL
            RelocEntry::new(EXTERNAL_FUNC_NAME, 4), // R_X86_64_PLT32
            RelocEntry::new("", 1),                 // R_X86_64_64
            RelocEntry::new(EXTERNAL_VAR_NAME, 1),  // R_X86_64_64
        ],
        _ => {
            println!("Skipping test for unsupported architecture: {:?}", arch);
            return;
        }
    };

    let output = gen_static_elf(arch, &symbols, &relocs).expect("Failed to generate static ELF");
    let elf_data = &output.data;
    let reloc_offsets = &output.reloc_offsets;

    // Define external symbols that the relocatable object requires
    extern "C" fn external_func() -> i32 {
        100
    }

    static EXTERNAL_VAR: i32 = 200;

    let mut symbol_map = HashMap::new();
    symbol_map.insert(EXTERNAL_FUNC_NAME, external_func as *const ());
    symbol_map.insert(EXTERNAL_VAR_NAME, &raw const EXTERNAL_VAR as *const ());

    let symbol_lookup_map = symbol_map.clone();
    let symbol_lookup =
        move |name: &str| -> Option<*const ()> { symbol_lookup_map.get(name).copied() };

    // Create ElfBinary from generated bytes
    let elf_binary = ElfBinary::new("test_static.o", &elf_data);
    println!("ElfBinary created, size: {}", elf_data.len());

    // Write to file for debugging
    std::fs::write("/tmp/test_static.o", &elf_data).expect("Failed to write ELF to file");

    // Load the relocatable object
    let mut loader = Loader::new();
    let obj = loader
        .load_relocatable(elf_binary)
        .expect("Failed to load relocatable object");
    println!("Relocatable object loaded");

    // Relocate the object with symbol resolution
    let relocated = obj
        .relocator()
        .symbols(&symbol_lookup)
        .relocate()
        .expect("Failed to relocate");
    println!("Relocation completed");

    println!("Relocated object base: {:?}", relocated.base());

    // Locate the base of the .data section via the `local_var` symbol
    let local_ptr = unsafe {
        relocated
            .get::<i32>(LOCAL_VAR_NAME)
            .expect("missing `local_var` in relocated object")
    };
    let local_addr = local_ptr.into_raw() as usize;
    println!("local_var addr: {:#x}", local_addr);
    // In gen_static_elf, local_var is at offset 0 in its section
    let data_base = local_addr;
    println!("data_base: {:#x}", data_base);

    let external_func_addr = symbol_map.get(EXTERNAL_FUNC_NAME).copied().unwrap() as usize;
    let external_var_addr = symbol_map.get(EXTERNAL_VAR_NAME).copied().unwrap() as usize;

    // Helpers
    unsafe fn read_u64(p: *const u8) -> u64 {
        let mut b = [0u8; 8];
        unsafe { core::ptr::copy_nonoverlapping(p, b.as_mut_ptr(), 8) };
        u64::from_le_bytes(b)
    }
    unsafe fn read_i32(p: *const u8) -> i32 {
        let mut b = [0u8; 4];
        unsafe { core::ptr::copy_nonoverlapping(p, b.as_mut_ptr(), 4) };
        i32::from_le_bytes(b)
    }

    // Verify relocations
    if arch == Arch::X86_64 {
        // reloc_offsets[0]: R_X86_64_64 -> external_func
        {
            let addr = (data_base + reloc_offsets[0] as usize) as *const u8;
            let val = unsafe { read_u64(addr) } as usize;
            assert_eq!(val, external_func_addr, "reloc_offsets[0] mismatch");
        }

        // reloc_offsets[1]: R_X86_64_GOTPCREL -> GOT entry - P
        {
            let p = (data_base + reloc_offsets[1] as usize) as *const u8;
            let val = unsafe { read_i32(p) };
            let target = (p as usize).wrapping_add(val as usize);
            let got_val = unsafe { read_u64(target as *const u8) } as usize;
            assert_eq!(got_val, external_var_addr, "reloc_offsets[1] mismatch");
        }

        // reloc_offsets[2]: R_X86_64_GOTPCREL -> GOT entry - P
        {
            let p = (data_base + reloc_offsets[2] as usize) as *const u8;
            let val = unsafe { read_i32(p) };
            let target = (p as usize).wrapping_add(val as usize);
            let got_val = unsafe { read_u64(target as *const u8) } as usize;
            assert_eq!(got_val, external_func_addr, "reloc_offsets[2] mismatch");
        }

        // reloc_offsets[3]: R_X86_64_PLT32 -> PLT entry - P
        {
            let p = (data_base + reloc_offsets[3] as usize) as *const u8;
            let val = unsafe { read_i32(p) };
            let target = (p as usize).wrapping_add(val as usize);
            if target != external_func_addr {
                let code = unsafe { read_u64(target as *const u8) };
                assert_eq!(
                    code & 0xffffffff,
                    0xfa1e0ff3,
                    "reloc_offsets[3] signature mismatch"
                );
            }
        }

        // reloc_offsets[4]: R_X86_64_64 (Relative-like) -> data_base
        {
            let addr = (data_base + reloc_offsets[4] as usize) as *const u8;
            let val = unsafe { read_u64(addr) } as usize;
            assert_eq!(val, data_base, "reloc_offsets[4] mismatch");
        }

        // reloc_offsets[5]: R_X86_64_64 (TLS-like) -> external_var
        {
            let addr = (data_base + reloc_offsets[5] as usize) as *const u8;
            let val = unsafe { read_u64(addr) } as usize;
            assert_eq!(val, external_var_addr, "reloc_offsets[5] mismatch");
        }
    }
}
